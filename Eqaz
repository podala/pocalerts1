# ============================================================
# FIXED Excel-faithful Goal Seek Engine
# ============================================================

from dataclasses import dataclass, asdict
from typing import List, Dict
from datetime import datetime
import logging

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(message)s"
)
logger = logging.getLogger("PRICING_ENGINE")


@dataclass
class IterationLog:
    iteration: int
    lift: float
    total: float
    error: float


@dataclass
class SolveResult:
    base: float
    sensitivity: float
    final_lift: float
    contribution_pct: float
    final_total: float
    iterations: List[IterationLog]


@dataclass
class AuditRecord:
    run_id: str
    timestamp: str
    before: Dict
    after: Dict
    stop_reason: str


class PricingLiftEngine:

    def __init__(self, tol=1e-6, max_iter=50):
        self.tol = tol
        self.max_iter = max_iter

    # --------------------------------------------------------
    # Correct BASE & S estimation using TWO VALID POINTS
    # --------------------------------------------------------
    def estimate_base_and_s(
        self,
        total1, lift1,
        total2, lift2
    ):
        S = (total2 - total1) / (lift2 - lift1)
        BASE = total1 - S * lift1
        return BASE, S

    def solve(
        self,
        before_total,
        before_lift,
        target_total,
        excel_reference_lift=1.676  # TEMP: until full NDC recompute is wired
    ):

        # --- Use Excel-consistent second point
        ref_total = target_total
        ref_lift = excel_reference_lift

        BASE, S = self.estimate_base_and_s(
            before_total, before_lift,
            ref_total, ref_lift
        )

        logger.info(f"Estimated BASE={BASE:.6f}, SENSITIVITY={S:.6f}")

        iterations = []
        lift = before_lift
        stop_reason = "MAX_ITER"

        for i in range(1, self.max_iter + 1):
            total = BASE + S * lift
            error = total - target_total

            iterations.append(
                IterationLog(i, round(lift, 6), round(total, 6), round(error, 6))
            )

            logger.info(
                f"Iter {i:02d} | lift={lift:.6f} | total={total:.6f} | error={error:.6f}"
            )

            if abs(error) <= self.tol:
                stop_reason = "CONVERGED"
                break

            lift = lift - error / S

        final_total = BASE + S * lift
        contribution_pct = (S * lift) / target_total * 100

        return SolveResult(
            base=round(BASE, 6),
            sensitivity=round(S, 6),
            final_lift=round(lift, 6),
            contribution_pct=round(contribution_pct, 1),
            final_total=round(final_total, 6),
            iterations=iterations
        ), stop_reason


# ============================================================
# RUN
# ============================================================

if __name__ == "__main__":

    engine = PricingLiftEngine()

    result, stop = engine.solve(
        before_total=337.0,
        before_lift=1.085,
        target_total=399.0
    )

    audit = AuditRecord(
        run_id="RUN_FIXED_001",
        timestamp=datetime.utcnow().isoformat(),
        before={"total": 337.0, "lift": 1.085},
        after=asdict(result),
        stop_reason=stop
    )

    print("\nFINAL AUDIT OUTPUT")
    print(audit)
