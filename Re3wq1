import logging
import re
import traceback
from engine.rule_parser import parse_expression, parse_path
from engine.utils import retry

logger = logging.getLogger("RuleEngine")

# ---------------- helpers ----------------

def _normalize(v):
    if isinstance(v, (int, float)): 
        return v
    if v is None:
        return None
    try:
        s = str(v).strip()
    except Exception:
        return v
    low = s.lower()
    if low in ("yes", "y", "true", "1"): return True
    if low in ("no", "n", "false", "0"): return False
    return low

def _get_value_forgiving(ctx: dict, key: str):
    """
    Return ctx[key]; if missing, try common header variants like underscores,
    and case-insensitive match. Logs when not found.
    """
    if key in ctx:
        return ctx[key]

    # Try common patterns like ScriptsYear1 / ScriptsYear_1 / Scripts1 / Scripts_1
    m = re.match(r'^(.*?)(Year)?_?(\d+)$', key)  # base, optional 'Year', number
    if m:
        base, has_year, num = m.group(1), m.group(2), m.group(3)
        candidates = [
            f"{base}Year{num}",
            f"{base}Year_{num}",
            f"{base}{num}",
            f"{base}_{num}",
        ]
        for c in candidates:
            if c in ctx:
                logger.debug(f"[value_path] '{key}' not found; using alias '{c}'")
                return ctx[c]

    lower_key = key.lower()
    for k in ctx.keys():
        if str(k).lower() == lower_key:
            logger.debug(f"[value_path] '{key}' not found; using case-insensitive match '{k}'")
            return ctx[k]

    logger.warning(f"[value_path] key '{key}' not found in context")
    return None

# --------------- executor ----------------

class RuleExecutor:
    """
    Executes a single rule template against a row for a specific year.
    Static context overrides row values by design (JSON > CSV).
    """

    def __init__(self, rule_template: dict, static_ctx: dict = None):
        self.rule = rule_template
        self.static_ctx = static_ctx or {}

    def _row_dict(self, row) -> dict:
        """
        Build the evaluation context.

        IMPORTANT: static overrides row (JSON > CSV) as requested.
        If a key exists in both, static value wins.
        """
        rd = row.to_dict() if hasattr(row, "to_dict") else dict(row)
        # Row first, then overwrite with statics so statics WIN
        # (opposite of earlier behavior).
        return {**rd, **self.static_ctx}

    def _log_condition_failure(self, cond, actual, expected, reason: str):
        logger.info(
            f"[conditions] FAIL path={cond.get('path')} "
            f"op={cond.get('operator')} expected={expected!r} actual={actual!r} reason={reason}"
        )

    def evaluate_conditions(self, row) -> bool:
        ctx = self._row_dict(row)
        conditions = self.rule.get("conditions", {}).get("all", [])
        if not conditions:
            return True

        for cond in conditions:
            field = cond.get("path", "").replace("$.","")
            operator = cond.get("operator", "equal")
            expected = cond.get("value")

            actual = ctx.get(field, None)
            n_actual = _normalize(actual)
            n_expected = _normalize(expected)

            try:
                if operator == "equal":
                    ok = (n_actual == n_expected)
                elif operator == "not_equal":
                    ok = (n_actual != n_expected)
                elif operator == "greater_than":
                    ok = (n_actual > n_expected)
                elif operator == "less_than":
                    ok = (n_actual < n_expected)
                elif operator == "greater_or_equal":
                    ok = (n_actual >= n_expected)
                elif operator == "less_or_equal":
                    ok = (n_actual <= n_expected)
                else:
                    self._log_condition_failure(cond, actual, expected, f"unsupported operator '{operator}'")
                    return False
            except Exception as e:
                self._log_condition_failure(cond, actual, expected, f"comparison error: {e}")
                return False

            if not ok:
                self._log_condition_failure(cond, actual, expected, "predicate evaluated to False")
                return False

        return True

    @retry(max_attempts=3)
    def evaluate_expression(self, expr: str, ctx: dict):
        """
        Evaluate a parsed Python expression with only 'row' in local scope.
        """
        try:
            return eval(expr, {}, {"row": ctx})
        except Exception as e:
            logger.error(
                "[expression] evaluation failed:\n"
                f"expr={expr}\nerror={e}\ntraceback=\n{traceback.format_exc()}"
            )
            raise

    def _calc_value_path(self, value_path_template: str, year: str, ctx: dict):
        key = parse_path(value_path_template, year)
        val = _get_value_forgiving(ctx, key)
        if val is None:
            logger.info(f"[value_path] resolved key='{key}' -> None")
        return val

    def _calc_expression(self, expr_template: str, year: str, ctx: dict):
        expr = parse_expression(expr_template, year)
        logger.debug(f"[expression] parsed: {expr}")
        return self.evaluate_expression(expr, ctx)

    def execute_row(self, row, year: str):
        rule_name = self.rule.get("name", "<unnamed>")
        logger.info(f"Executing rule='{rule_name}' year_index={year}")

        ctx = self._row_dict(row)
        try:
            if self.evaluate_conditions(row):
                calc = self.rule.get("calculation", {})
                ctype = calc.get("type")
                if ctype == "value_path":
                    return self._calc_value_path(calc.get("value_path", ""), year, ctx)
                elif ctype == "expression":
                    return self._calc_expression(calc.get("value", ""), year, ctx)
                else:
                    logger.error(f"[calc] Unsupported calculation type: {ctype}")
                    return None
            else:
                fb = self.rule.get("else", {})
                ftype = fb.get("type", "expression")  # default to expression
                if ftype == "value_path":
                    return self._calc_value_path(fb.get("value_path", ""), year, ctx)
                else:
                    return self._calc_expression(fb.get("value", ""), year, ctx)
        except Exception as e:
            logger.error(f"[execute_row] rule='{rule_name}' year_index={year} failed: {e}")
            return None
